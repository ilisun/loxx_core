// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LANDTILE_ROUTING_H_
#define FLATBUFFERS_GENERATED_LANDTILE_ROUTING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Routing {

struct Node;
struct NodeBuilder;

struct Edge;
struct EdgeBuilder;

struct ShapePoint;
struct ShapePointBuilder;

struct LandTile;
struct LandTileBuilder;

enum class RoadClass : int8_t {
  MOTORWAY = 0,
  PRIMARY = 1,
  SECONDARY = 2,
  RESIDENTIAL = 3,
  FOOTWAY = 4,
  PATH = 5,
  STEPS = 6,
  MIN = MOTORWAY,
  MAX = STEPS
};

inline const RoadClass (&EnumValuesRoadClass())[7] {
  static const RoadClass values[] = {
    RoadClass::MOTORWAY,
    RoadClass::PRIMARY,
    RoadClass::SECONDARY,
    RoadClass::RESIDENTIAL,
    RoadClass::FOOTWAY,
    RoadClass::PATH,
    RoadClass::STEPS
  };
  return values;
}

inline const char * const *EnumNamesRoadClass() {
  static const char * const names[8] = {
    "MOTORWAY",
    "PRIMARY",
    "SECONDARY",
    "RESIDENTIAL",
    "FOOTWAY",
    "PATH",
    "STEPS",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoadClass(RoadClass e) {
  if (::flatbuffers::IsOutRange(e, RoadClass::MOTORWAY, RoadClass::STEPS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoadClass()[index];
}

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_LAT_Q = 6,
    VT_LON_Q = 8,
    VT_FIRST_EDGE = 10,
    VT_EDGE_COUNT = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  int32_t lat_q() const {
    return GetField<int32_t>(VT_LAT_Q, 0);
  }
  int32_t lon_q() const {
    return GetField<int32_t>(VT_LON_Q, 0);
  }
  uint32_t first_edge() const {
    return GetField<uint32_t>(VT_FIRST_EDGE, 0);
  }
  uint16_t edge_count() const {
    return GetField<uint16_t>(VT_EDGE_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_LAT_Q, 4) &&
           VerifyField<int32_t>(verifier, VT_LON_Q, 4) &&
           VerifyField<uint32_t>(verifier, VT_FIRST_EDGE, 4) &&
           VerifyField<uint16_t>(verifier, VT_EDGE_COUNT, 2) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Node::VT_ID, id, 0);
  }
  void add_lat_q(int32_t lat_q) {
    fbb_.AddElement<int32_t>(Node::VT_LAT_Q, lat_q, 0);
  }
  void add_lon_q(int32_t lon_q) {
    fbb_.AddElement<int32_t>(Node::VT_LON_Q, lon_q, 0);
  }
  void add_first_edge(uint32_t first_edge) {
    fbb_.AddElement<uint32_t>(Node::VT_FIRST_EDGE, first_edge, 0);
  }
  void add_edge_count(uint16_t edge_count) {
    fbb_.AddElement<uint16_t>(Node::VT_EDGE_COUNT, edge_count, 0);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    int32_t lat_q = 0,
    int32_t lon_q = 0,
    uint32_t first_edge = 0,
    uint16_t edge_count = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_first_edge(first_edge);
  builder_.add_lon_q(lon_q);
  builder_.add_lat_q(lat_q);
  builder_.add_id(id);
  builder_.add_edge_count(edge_count);
  return builder_.Finish();
}

struct Edge FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EdgeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FROM_NODE = 4,
    VT_TO_NODE = 6,
    VT_LENGTH_M = 8,
    VT_SPEED_MPS = 10,
    VT_FOOT_SPEED_MPS = 12,
    VT_ONEWAY = 14,
    VT_ROAD_CLASS = 16,
    VT_ACCESS_MASK = 18,
    VT_SHAPE_START = 20,
    VT_SHAPE_COUNT = 22,
    VT_ENCODED_POLYLINE = 24
  };
  uint32_t from_node() const {
    return GetField<uint32_t>(VT_FROM_NODE, 0);
  }
  uint32_t to_node() const {
    return GetField<uint32_t>(VT_TO_NODE, 0);
  }
  float length_m() const {
    return GetField<float>(VT_LENGTH_M, 0.0f);
  }
  float speed_mps() const {
    return GetField<float>(VT_SPEED_MPS, 0.0f);
  }
  float foot_speed_mps() const {
    return GetField<float>(VT_FOOT_SPEED_MPS, 0.0f);
  }
  bool oneway() const {
    return GetField<uint8_t>(VT_ONEWAY, 0) != 0;
  }
  Routing::RoadClass road_class() const {
    return static_cast<Routing::RoadClass>(GetField<int8_t>(VT_ROAD_CLASS, 0));
  }
  uint16_t access_mask() const {
    return GetField<uint16_t>(VT_ACCESS_MASK, 0);
  }
  uint32_t shape_start() const {
    return GetField<uint32_t>(VT_SHAPE_START, 0);
  }
  uint16_t shape_count() const {
    return GetField<uint16_t>(VT_SHAPE_COUNT, 0);
  }
  const ::flatbuffers::String *encoded_polyline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENCODED_POLYLINE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FROM_NODE, 4) &&
           VerifyField<uint32_t>(verifier, VT_TO_NODE, 4) &&
           VerifyField<float>(verifier, VT_LENGTH_M, 4) &&
           VerifyField<float>(verifier, VT_SPEED_MPS, 4) &&
           VerifyField<float>(verifier, VT_FOOT_SPEED_MPS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ONEWAY, 1) &&
           VerifyField<int8_t>(verifier, VT_ROAD_CLASS, 1) &&
           VerifyField<uint16_t>(verifier, VT_ACCESS_MASK, 2) &&
           VerifyField<uint32_t>(verifier, VT_SHAPE_START, 4) &&
           VerifyField<uint16_t>(verifier, VT_SHAPE_COUNT, 2) &&
           VerifyOffset(verifier, VT_ENCODED_POLYLINE) &&
           verifier.VerifyString(encoded_polyline()) &&
           verifier.EndTable();
  }
};

struct EdgeBuilder {
  typedef Edge Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_from_node(uint32_t from_node) {
    fbb_.AddElement<uint32_t>(Edge::VT_FROM_NODE, from_node, 0);
  }
  void add_to_node(uint32_t to_node) {
    fbb_.AddElement<uint32_t>(Edge::VT_TO_NODE, to_node, 0);
  }
  void add_length_m(float length_m) {
    fbb_.AddElement<float>(Edge::VT_LENGTH_M, length_m, 0.0f);
  }
  void add_speed_mps(float speed_mps) {
    fbb_.AddElement<float>(Edge::VT_SPEED_MPS, speed_mps, 0.0f);
  }
  void add_foot_speed_mps(float foot_speed_mps) {
    fbb_.AddElement<float>(Edge::VT_FOOT_SPEED_MPS, foot_speed_mps, 0.0f);
  }
  void add_oneway(bool oneway) {
    fbb_.AddElement<uint8_t>(Edge::VT_ONEWAY, static_cast<uint8_t>(oneway), 0);
  }
  void add_road_class(Routing::RoadClass road_class) {
    fbb_.AddElement<int8_t>(Edge::VT_ROAD_CLASS, static_cast<int8_t>(road_class), 0);
  }
  void add_access_mask(uint16_t access_mask) {
    fbb_.AddElement<uint16_t>(Edge::VT_ACCESS_MASK, access_mask, 0);
  }
  void add_shape_start(uint32_t shape_start) {
    fbb_.AddElement<uint32_t>(Edge::VT_SHAPE_START, shape_start, 0);
  }
  void add_shape_count(uint16_t shape_count) {
    fbb_.AddElement<uint16_t>(Edge::VT_SHAPE_COUNT, shape_count, 0);
  }
  void add_encoded_polyline(::flatbuffers::Offset<::flatbuffers::String> encoded_polyline) {
    fbb_.AddOffset(Edge::VT_ENCODED_POLYLINE, encoded_polyline);
  }
  explicit EdgeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Edge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Edge>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Edge> CreateEdge(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t from_node = 0,
    uint32_t to_node = 0,
    float length_m = 0.0f,
    float speed_mps = 0.0f,
    float foot_speed_mps = 0.0f,
    bool oneway = false,
    Routing::RoadClass road_class = Routing::RoadClass::MOTORWAY,
    uint16_t access_mask = 0,
    uint32_t shape_start = 0,
    uint16_t shape_count = 0,
    ::flatbuffers::Offset<::flatbuffers::String> encoded_polyline = 0) {
  EdgeBuilder builder_(_fbb);
  builder_.add_encoded_polyline(encoded_polyline);
  builder_.add_shape_start(shape_start);
  builder_.add_foot_speed_mps(foot_speed_mps);
  builder_.add_speed_mps(speed_mps);
  builder_.add_length_m(length_m);
  builder_.add_to_node(to_node);
  builder_.add_from_node(from_node);
  builder_.add_shape_count(shape_count);
  builder_.add_access_mask(access_mask);
  builder_.add_road_class(road_class);
  builder_.add_oneway(oneway);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Edge> CreateEdgeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t from_node = 0,
    uint32_t to_node = 0,
    float length_m = 0.0f,
    float speed_mps = 0.0f,
    float foot_speed_mps = 0.0f,
    bool oneway = false,
    Routing::RoadClass road_class = Routing::RoadClass::MOTORWAY,
    uint16_t access_mask = 0,
    uint32_t shape_start = 0,
    uint16_t shape_count = 0,
    const char *encoded_polyline = nullptr) {
  auto encoded_polyline__ = encoded_polyline ? _fbb.CreateString(encoded_polyline) : 0;
  return Routing::CreateEdge(
      _fbb,
      from_node,
      to_node,
      length_m,
      speed_mps,
      foot_speed_mps,
      oneway,
      road_class,
      access_mask,
      shape_start,
      shape_count,
      encoded_polyline__);
}

struct ShapePoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShapePointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAT_Q = 4,
    VT_LON_Q = 6
  };
  int32_t lat_q() const {
    return GetField<int32_t>(VT_LAT_Q, 0);
  }
  int32_t lon_q() const {
    return GetField<int32_t>(VT_LON_Q, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAT_Q, 4) &&
           VerifyField<int32_t>(verifier, VT_LON_Q, 4) &&
           verifier.EndTable();
  }
};

struct ShapePointBuilder {
  typedef ShapePoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lat_q(int32_t lat_q) {
    fbb_.AddElement<int32_t>(ShapePoint::VT_LAT_Q, lat_q, 0);
  }
  void add_lon_q(int32_t lon_q) {
    fbb_.AddElement<int32_t>(ShapePoint::VT_LON_Q, lon_q, 0);
  }
  explicit ShapePointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShapePoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShapePoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShapePoint> CreateShapePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lat_q = 0,
    int32_t lon_q = 0) {
  ShapePointBuilder builder_(_fbb);
  builder_.add_lon_q(lon_q);
  builder_.add_lat_q(lat_q);
  return builder_.Finish();
}

struct LandTile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LandTileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_Z = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_NODES = 10,
    VT_EDGES = 12,
    VT_SHAPES = 14,
    VT_VERSION = 16,
    VT_CHECKSUM = 18,
    VT_PROFILE_MASK = 20
  };
  uint16_t z() const {
    return GetField<uint16_t>(VT_Z, 0);
  }
  uint32_t x() const {
    return GetField<uint32_t>(VT_X, 0);
  }
  uint32_t y() const {
    return GetField<uint32_t>(VT_Y, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::Node>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::Edge>> *edges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::Edge>> *>(VT_EDGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::ShapePoint>> *shapes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Routing::ShapePoint>> *>(VT_SHAPES);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const ::flatbuffers::String *checksum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHECKSUM);
  }
  uint32_t profile_mask() const {
    return GetField<uint32_t>(VT_PROFILE_MASK, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_Z, 2) &&
           VerifyField<uint32_t>(verifier, VT_X, 4) &&
           VerifyField<uint32_t>(verifier, VT_Y, 4) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_EDGES) &&
           verifier.VerifyVector(edges()) &&
           verifier.VerifyVectorOfTables(edges()) &&
           VerifyOffset(verifier, VT_SHAPES) &&
           verifier.VerifyVector(shapes()) &&
           verifier.VerifyVectorOfTables(shapes()) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_CHECKSUM) &&
           verifier.VerifyString(checksum()) &&
           VerifyField<uint32_t>(verifier, VT_PROFILE_MASK, 4) &&
           verifier.EndTable();
  }
};

struct LandTileBuilder {
  typedef LandTile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_z(uint16_t z) {
    fbb_.AddElement<uint16_t>(LandTile::VT_Z, z, 0);
  }
  void add_x(uint32_t x) {
    fbb_.AddElement<uint32_t>(LandTile::VT_X, x, 0);
  }
  void add_y(uint32_t y) {
    fbb_.AddElement<uint32_t>(LandTile::VT_Y, y, 0);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::Node>>> nodes) {
    fbb_.AddOffset(LandTile::VT_NODES, nodes);
  }
  void add_edges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::Edge>>> edges) {
    fbb_.AddOffset(LandTile::VT_EDGES, edges);
  }
  void add_shapes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::ShapePoint>>> shapes) {
    fbb_.AddOffset(LandTile::VT_SHAPES, shapes);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(LandTile::VT_VERSION, version, 0);
  }
  void add_checksum(::flatbuffers::Offset<::flatbuffers::String> checksum) {
    fbb_.AddOffset(LandTile::VT_CHECKSUM, checksum);
  }
  void add_profile_mask(uint32_t profile_mask) {
    fbb_.AddElement<uint32_t>(LandTile::VT_PROFILE_MASK, profile_mask, 0);
  }
  explicit LandTileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LandTile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LandTile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LandTile> CreateLandTile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t z = 0,
    uint32_t x = 0,
    uint32_t y = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::Edge>>> edges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Routing::ShapePoint>>> shapes = 0,
    uint32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> checksum = 0,
    uint32_t profile_mask = 0) {
  LandTileBuilder builder_(_fbb);
  builder_.add_profile_mask(profile_mask);
  builder_.add_checksum(checksum);
  builder_.add_version(version);
  builder_.add_shapes(shapes);
  builder_.add_edges(edges);
  builder_.add_nodes(nodes);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_z(z);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LandTile> CreateLandTileDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t z = 0,
    uint32_t x = 0,
    uint32_t y = 0,
    const std::vector<::flatbuffers::Offset<Routing::Node>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<Routing::Edge>> *edges = nullptr,
    const std::vector<::flatbuffers::Offset<Routing::ShapePoint>> *shapes = nullptr,
    uint32_t version = 0,
    const char *checksum = nullptr,
    uint32_t profile_mask = 0) {
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<Routing::Node>>(*nodes) : 0;
  auto edges__ = edges ? _fbb.CreateVector<::flatbuffers::Offset<Routing::Edge>>(*edges) : 0;
  auto shapes__ = shapes ? _fbb.CreateVector<::flatbuffers::Offset<Routing::ShapePoint>>(*shapes) : 0;
  auto checksum__ = checksum ? _fbb.CreateString(checksum) : 0;
  return Routing::CreateLandTile(
      _fbb,
      z,
      x,
      y,
      nodes__,
      edges__,
      shapes__,
      version,
      checksum__,
      profile_mask);
}

inline const Routing::LandTile *GetLandTile(const void *buf) {
  return ::flatbuffers::GetRoot<Routing::LandTile>(buf);
}

inline const Routing::LandTile *GetSizePrefixedLandTile(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Routing::LandTile>(buf);
}

inline bool VerifyLandTileBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Routing::LandTile>(nullptr);
}

inline bool VerifySizePrefixedLandTileBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Routing::LandTile>(nullptr);
}

inline void FinishLandTileBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Routing::LandTile> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLandTileBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Routing::LandTile> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Routing

#endif  // FLATBUFFERS_GENERATED_LANDTILE_ROUTING_H_
