# Спецификация библиотеки маршрутизации на данных OpenStreetMap
**Проект:** Offline/Online Routing Core  
**Ядро:** C++17/20  
**SDK:** iOS (.xcframework), Android (.aar + JNI)  
**Профили:** Car, Foot, Boat  
**Режимы:** Онлайн (сервер), оффлайн (моб. устройства)  
**Поиск:** Полноценный геокодинг (адреса/POI)

---

## 0) Цели и границы
**Цель:** разработать собственное производительное ядро маршрутизации, совместимое с OSM, работающее как на сервере (онлайн API), так и оффлайн на iOS/Android, с поддержкой поиска по названиям и тремя профилями движения (Car/Foot/Boat), расчётом длины/ETA и быстрым инкрементальным перестроением.

**Не входит в v1:** голосовые подсказки, трафик в реальном времени, платные ограничения, полноценная морская навигация по стандартам ENC (S-57/S-101).

---

## 1) Ключевые решения и альтернативы (с обоснованием)

### 1.1 Язык и рантайм ядра
- **Варианты:** C++ / Rust / Go  
- **Выбрано:** **C++17/20**  
- **Почему:** максимальная производительность и зрелая экосистема для графов/геометрии; простые и стабильные биндинги на iOS/Android; опыт индустрии (Valhalla/OSRM/GraphHopper-core).

### 1.2 Схема хранения данных
- **Варианты:** монолитный файл на регион / тайловая структура / гибрид  
- **Выбрано:** **тайлы (tile-based)**  
- **Почему:** быстрые частичные загрузки, простые оффлайн-пакеты по регионам, удобные дельта-обновления, сниженная память.

### 1.3 Модель профилей
- **Варианты:** плагинные “costing” функции / раздельные профили  
- **Выбрано:** **раздельные профили (Car/Foot/Boat)**  
- **Почему:** проще изолировать логику проходимости/скоростей/штрафов, легче оптимизировать, понятнее API.

### 1.4 Геокодинг
- **Варианты:** простой POI-словарь / полноценный адресный геокодинг  
- **Выбрано:** **полноценный геокодинг**  
- **Почему:** соответствует требованиям (поиск по названию, адреса, улицы, дома) онлайн и оффлайн; потребует отдельного индекса.

### 1.5 Перестроение маршрута
- **Варианты:** полная перестройка / инкрементальная  
- **Выбрано:** **инкрементальная**  
- **Почему:** меньше латентность и расход батареи на мобильных, лучший UX при отклонениях.

### 1.6 Boat-профиль (вода)
- **Варианты:** использовать только `route=ferry` (как дороги) / строить граф водных путей / строить навигационный меш для открытой воды  
- **Выбрано:** **гибрид:**  
  - **реки/каналы/озёра** → граф по `waterway=*` (как дорожный, с ограничениями направления/скоростей),  
  - **открытая вода/береговая линия** → **сетевая модель (grid/navmesh)** c препятствиями (острова, суша) и сглаживанием траектории.  
- **Почему:** классические дорожные роутеры не покрывают открытую воду; гибрид закрывает оба кейса (внутренние водные пути и море/озёра) и позволяет «обходить острова».

---

## 2) Архитектура

### 2.1 Общий обзор
- **Core (C++):** графовые структуры, чтение тайлов, алгоритмы (A*, bi-A*, CH — позже), профили, геометрия, лодочный grid/navmesh.  
- **Geocoder (C++):** адресный/POI-индекс (SQLite/LMDB + компрессия), токенизация/нормализация, ранжирование.  
- **Bindings:**  
  - iOS: Objective-C++ мост → Swift, упаковка в `.xcframework`  
  - Android: JNI → Kotlin, упаковка в `.aar`  
- **Server:** лёгкий HTTP слой (C++/nghttp2 или C++/oatpp), использует то же ядро.

### 2.2 Данные: формат оффлайн-пакетов
**Состав пакета региона:**
- `routing_tiles/` — тайлы графа (Car/Foot); бинарный формат (FlatBuffers/Cap’n Proto/Protobuf, **выбрать FlatBuffers** для zero-copy).  
- `water_tiles/` — тайлы grid/navmesh и граф `waterway`.  
- `geocoding.db` — адресный/POI индекс (SQLite с FTS5 + вспомогательные таблицы и пространственные индексы R-tree).  
- `meta.json` — версия, чексуммы, bbox, дата OSM extract, версия схемы.

**Обоснование:**
- **FlatBuffers**: быстрый mmap, минимальные аллокации.  
- **SQLite+FTS5:** зрелый FTS, простые оффлайн-запросы, кроссплатформенность.

### 2.3 Графовые структуры
- **Land graph:** edge-based граф (узлы — точки, рёбра — отрезки с геометрией), adjacency list с компактными ID, отдельные индексы для переходов и ограничений (oneway, access).  
- **Turn restrictions (этап 2):** edge-based penalization.  
- **Water graph:**  
  - `waterway` линейный граф (реки/каналы) с направлением и скоростями/течениями (если доступны).  
  - **Sea/Lake grid/navmesh:** иерархическая сетка (quadtree уровни) с ячейками “проходимо/нет” (вода/суша), узловые порталы на береговой линии; хранится в тайлах, поддерживает coarse→fine планирование.

### 2.4 Алгоритмы маршрутизации
- **Поиск:** bi-A* с эвристикой great-circle (Haversine), при необходимости ALT/landmarks (этап 2–3).  
- **Иерархия (этап 2):** Contraction Hierarchies для Car/Foot.  
- **Boat:**  
  - На `waterway` — как land-graph,  
  - На grid/navmesh — A* с мульти-масштабом; пост-сглаживание (Douglas–Peucker + bezier/catmull).  
- **Смешанные маршруты:** стыковочные узлы “shore/port” позволяют комбинировать foot↔boat.

### 2.5 Инкрементальное перестроение
- Храним **коридор маршрута** (polyline + индекс ближайшего сегмента).  
- При отклонении:  
  - проецируем текущее положение на коридор;  
  - если вне допуска → запускаем поиск **от текущей позиции до “якорной точки” впереди** (waypoint через N метров/сегментов);  
  - переиспользуем результаты предыдущего поиска (лимитируем область повторного поиска тайлами вокруг коридора).  
- На воде: корректируем маршрут с учётом препятствий (reclip по береговой линии), пересчёт только завершающей части.

---

## 3) Профили движения

### 3.1 Общие поля “ребра”
- длина (м), средняя скорость (м/с), тип пути (highway class / surface / access), штрафы (узкие улицы, светофоры — позже), ограничения (oneway), геометрия (polyline).

### 3.2 Car
- **Доступность:** `highway=*`, исключаем `footway`, `path`, `steps`, учитываем `access`, `motor_vehicle`.  
- **Скорости:** по классу дороги + локальные `maxspeed` (если есть).  
- **Штрафы:** развороты/манёвры (этап 2), светофоры/пробки (позже).  
- **ETA:** длина/скорость + манёвренные штрафы.

### 3.3 Foot
- **Доступность:** `foot=yes/designated`, `path`, `footway`, `residential`, парки, тропы; исключаем автомагистрали.  
- **Скорость:** базовая 4.5–5.0 км/ч + штрафы за уклон (если есть DEM, этап 2).  
- **ETA:** с поправками на уклон/тип покрытия.

### 3.4 Boat
- **Доступность:**  
  - `waterway=*` (реки/каналы/озёра) — по графу;  
  - **open water** — по grid/navmesh, “суша” и острова как препятствия.  
- **Скорость:** профильная (например 10–20 км/ч), модификаторы по типу водоёма; (течения/ветер — позже).  
- **ETA:** расстояние/скорость + возможные штрафы на узких местах/порталах.

---

## 4) Геокодинг (поиск)

### 4.1 Пайплайн подготовки
- Источник: OSM PBF; нормализация имен, генерация токенов (языковые формы), построение **адресной иерархии** (страна → регион → город → улица → дом).  
- Индексы:
  - **FTS5** по именам (улицы/POI/нас. пункты),  
  - пространственный R-tree для bbox/точек,  
  - таблица алиасов/синонимов.

### 4.2 Запросы
- `search(text[, bbox]) → [results]`  
  - нормализация, токенизация, ранжирование: текстовый скор + близость к bbox + тип (address/POI).  
  - оффлайн: прямой SQLite-запрос; онлайн: HTTP к серверу (тот же индекс на SSD).

### 4.3 Ответ
```json
{
  "items": [
    { "name": "Невский проспект, 1", "type": "address",
      "lat": 59.935, "lon": 30.325, "bbox": [ ... ], "score": 0.91 }
  ]
}

---

## 5) API (ядро и сервер)

### 5.1 C++ Core API (упрощённый)
```cpp
struct Coord { double lat, lon; };
enum class Profile { Car, Foot, Boat };

struct RouteOptions {
  Profile profile;
  std::vector<Coord> waypoints; // start, ..., end
  bool allow_reuse_prev = true; // инкрементально
  double corridor_width_m = 80; // для инкремента
};

struct RouteResult {
  std::vector<Coord> polyline;
  double distance_m;
  double duration_s;
};

class Router {
public:
  Router(const std::string& data_root); // путь к оффлайн-пакету
  RouteResult route(const RouteOptions&);
  // геокодер:
  std::vector<SearchItem> search(const std::string& text,
                                 const std::optional<BBox>& area);
};
```

### 5.2 iOS (Swift)
```swift
let router = Router(dataRoot: localPackagePath)
let opts = RouteOptions(profile: .boat, waypoints: [a, b], allowReusePrev: true)
let res = try router.route(opts)
// res.polyline -> рисуем в MapLibre
```

### 5.3 Android (Kotlin)
```kotlin
val router = Router(localPackagePath)
val res = router.route(RouteOptions(Profile.BOAT, listOf(a, b)))
```

### 5.4 HTTP Server (микросервис)

- POST /route → {profile, waypoints} → {polyline, distance_m, duration_s}
- GET /search?q=...&bbox=... → [items]
- POST /matrix (этап 2) → матрица времени/расстояний

Формат: JSON; сжатие gzip; rate-limit.

---

## 6) Обновления, кэш, размеры

- Пакеты: региональные ZIP, версия схемы + дата OSM extract.
- Обновления: полные (v1), дельта-тайлы (этап 2).
- Кэш: mmap тайлов на чтение; LRU кэш десериализованных структур.
- Размеры ориентиры (регион ≈ “область”):
  - routing_tiles: 50–200 МБ
  - water_tiles: 20–100 МБ (зависит от сетки)
  - geocoding.db: 50–300 МБ (Сильно зависит от плотности данных.)

---

## 7) Производительность (целевые показатели v1)

- Маршрут в городе (Car/Foot): < 150 мс на девайсе среднего класса.
- Boat (short/medium): < 300–500 мс (с зависимостью от размера акватории; оптимизировать сетку).
- Инкрементальное перестроение: < 120 мс.
- Поиск (оффлайн): < 100 мс на первые 10 результатов.

---

## 8) Качество и тестирование

- Юнит-тесты: алгоритмы A*, конвертеры тайлов, геометрия (пересечения с берегом).
- Golden-routes: набор эталонных маршрутов по каждому профилю (сравнение дистанции/ETA, стабильность).
- Property-based: “boat polyline не пересекает сушу”, “foot не заходит на автомагистраль” и т.п.
- Нагрузочные: массовые запросы на сервере, профилирование памяти/CPU.
- Интеграционные (мобильные): холодный/тёплый старт, работа при низкой памяти, инкрементальный рероут.

---

## 9) Ошибки и устойчивость

- Нет подходящего пути: код NO_ROUTE, вернуть ближайший возможный сегмент.
- Повреждённые тайлы: DATA_CORRUPT, инициировать повторную загрузку пакета.
- Несовместимая версия схемы: SCHEMA_MISMATCH, требовать обновления пакета/SDK.
- Поиск без результатов: пустой список, http 200.

---

## 10) Безопасность и приватность

- Оффлайн режим: данные о местоположении не покидают устройство.
- Онлайн: минимальные логи, анонимизация координат, опциональная агрегация метрик (latency/ошибки) без PII.

---

## 11) Лицензии и атрибуция

- Данные OSM: ODbL — указать «© OpenStreetMap contributors».
- Собственные индексы/пакеты: лицензия проекта (MIT/Apache-2.0), но соблюсти условия ODbL при распространении производных баз (share-alike).
- Карты (клиент): атрибуции источников рендера (OpenFreeMap/OpenMapTiles/OSM).

---

## 12) Дорожная карта

- v1: Core Car/Foot/Boat; тайлы; оффлайн пакеты; геокодинг (адреса/POI); инкрементальный рероут; сервер /route, /search.
- v1.1: CH для Car/Foot; ALT-landmarks; дельта-обновления тайлов; расширенные ограничения (turn-restrictions).
- v1.2: улучшения Boat (скорости по типу акватории, улучшенное сглаживание, опционально — течения/ветер, если есть данные).
- v2: isochrones, matrix, map-matching, трафик-адаптер.

---

## 13) Риски

- Сложность Boat-навигации (правильная береговая линия, “узкие места”);
- Размер оффлайн-индекса геокодинга;
- Поддержка разных языков/склонений в поиске;
- Производительность на старых устройствах (ARMv8 с низкими частотами).